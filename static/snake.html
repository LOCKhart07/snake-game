<!DOCTYPE html>
<html>
  <head>
    <title>Snake üêç</title>
    <meta charset="UTF-8" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      body {
        background: #373636;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      canvas {
        border: 1px solid white;
      }

      /* Style the popup container */
      #popup-container {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.5);
        /* display: none; */
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      .hidden {
        display: none;
      }

      /* Style the popup content */
      #popup-content {
        background-color: #fff;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 10px;
        width: 300px;
        height: 200px;
        text-align: center;
      }

      /* Style the close button */
      #popup-close {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 18px;
        cursor: pointer;
      }

      /* Style the trigger button */
      #popup-trigger {
        background-color: #4caf50;
        color: #fff;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Show the popup when the trigger button is clicked */
      #popup-trigger:hover {
        background-color: #3e8e41;
      }
    </style>
  </head>
  <body>
    <!-- The popup container -->
    <div id="popup-container" class="hidden">
      <!-- The popup content -->
      <div id="popup-content">
        <h2>Popup Title</h2>
        <p>This is the popup content.</p>
        <button id="popup-close">Close</button>
      </div>
    </div>
    <!-- The trigger button -->
    <!-- <button id="popup-trigger" style="position: absolute; left: -0px">
      Open Popup
    </button> -->
    <div class="score-container" style="position: absolute; left: 10px">
      <div class="score" id="current-score">12</div>
      <div class="score" id="personal-best">60</div>
    </div>
    <canvas width="500" height="500" id="game"></canvas>
    <div class="leaderboard-container" style="position: absolute; right: 10px">
      <table id="leaderboard">
        <thead>
          <tr>
            <th>Username</th>
            <th>Score</th>
            <th>Scored At</th>
            <th>Time Taken (s)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      // Get the popup container and trigger button
      const popupContainer = document.getElementById("popup-container");
      // const popupTrigger = document.getElementById("popup-trigger");
      const popupClose = document.getElementById("popup-close");
      const current_score_dom = document.getElementById("current-score");
      const personal_best_dom = document.getElementById("personal-best");

      // Add an event listener to the trigger button
      // popupTrigger.addEventListener("click", () => {
      //   // Show the popup container
      //   console.log("opening popup");
      //   popupContainer.classList.remove("hidden");
      // });

      // Add an event listener to the close button
      popupClose.addEventListener("click", () => {
        // Hide the popup container
        popupContainer.classList.add("hidden");
      });

      var canvas = document.getElementById("game");
      var context = canvas.getContext("2d");
      const leaderboard = document.getElementById("leaderboard");
      var pb_broken = false;

      const SNAKE_BODY_GRADIENT = { start: [24, 87, 39], end: [15, 54, 24] };
      const SNAKE_INITIAL_LENGTH = 4;
      // const SNAKE_EAT_SOUND = new Audio("gulp.mp3");
      const API_BASE_URL = "http://localhost:5000/api/";

      // setTimeout()

      // var top_scores = [];
      const leaderboardRows = [];

      function get_scores() {
        console.log("fetching scores");
        // console.log(leaderboard.tBodies);
        const url = API_BASE_URL + "top-score";
        const options = {
          method: "GET",
          params: new URLSearchParams({
            page: 1,
            per_page: 10,
          }),
        };
        fetch(url, options)
          .then((response) => response.json())
          .then((data) => {
            // Remove old rows
            var rowCount = leaderboard.rows.length;
            for (var i = 1; i < rowCount; i++) {
              leaderboard.deleteRow(1);
            }
            data.forEach((score) => {
              const row = document.createElement("tr");
              row.innerHTML = `
          <td>${score.username}</td>
          <td>${score.score}</td>
          <td>${new Date(score.scoredAt).toLocaleString()}</td>
          <td>${parseInt(score.timeTakenSeconds)}</td>
        `;
              // leaderboardRows.push(row);
              leaderboard.tBodies[0].appendChild(row);
            });
          });
      }

      function send_score_to_save(username, score, time_taken) {
        console.log("saving score");
        const url = API_BASE_URL + "score";
        fetch(url, {
          method: "POST", // or 'PUT', 'DELETE', etc.
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            username: username,
            score: score,
            timeTakenSeconds: time_taken,
          }),
        });
      }
      get_scores();
      setInterval(get_scores, 5000);

      function calculateScore(length) {
        return (length - SNAKE_INITIAL_LENGTH) * 1;
      }

      function calculateGradient(gradientSteps, i, firstColor, secondColor) {
        // const green = [0, 128, 0]; // RGB values for green
        // const lightGreen = [0, 255, 0]; // RGB values for light green

        const step = i / (gradientSteps - 1);
        const r = Math.round(
          firstColor[0] + (secondColor[0] - firstColor[0]) * step
        );
        const g = Math.round(
          firstColor[1] + (secondColor[1] - firstColor[1]) * step
        );
        const b = Math.round(
          firstColor[2] + (secondColor[2] - firstColor[2]) * step
        );

        return `rgba(${r}, ${g}, ${b}, 1)`;
      }

      // the canvas width & height, snake x & y, and the apple x & y, all need to be a multiples of the grid size in order for collision detection to work
      // (e.g. 16 * 25 = 400)
      var grid = 20;

      var personal_best_score = localStorage.getItem("snake_highscore");

      var username = localStorage.getItem("username");
      if (username === "" || username === null) {
        username = prompt("Enter your username:");
        console.log("Username: " + username);
        localStorage.setItem("username", username);
      }
      function pause_game() {
        game_paused = true;
      }

      function unpause_game() {
        game_paused = false;
        requestAnimationFrame(loop);
      }

      var game_paused = false;

      class Snake {
        constructor(x, y, grid) {
          this.x = x;
          this.y = y;
          this.dx = grid;
          this.dy = 0;
          this.dxToApply = grid;
          this.dyToApply = 0;
          this.cells = [];
          this.maxCells = SNAKE_INITIAL_LENGTH;
          this.score = 0;
          this.autoplay = false;
        }

        queue_turn_left() {
          this.dxToApply = -grid;
          this.dyToApply = 0;
        }
        queue_turn_right() {
          this.dxToApply = grid;
          this.dyToApply = 0;
        }
        queue_turn_up() {
          this.dyToApply = -grid;
          this.dxToApply = 0;
        }
        queue_turn_down() {
          this.dyToApply = grid;
          this.dxToApply = 0;
        }

        move() {
          this.x += this.dx;
          this.y += this.dy;
        }

        flush_queued_move() {
          this.dx = this.dxToApply;
          this.dy = this.dyToApply;
        }

        increase_length() {
          this.maxCells++;
          this.score = calculateScore(this.maxCells);
        }

        doOptimalMove(x, y) {
          x = x / grid;
          y = y / grid;
          console.log(x, "   ", y);

          // // left
          // if (snake.dx === 20) {
          // }

          // //Right
          // else if (snake.dx === -20 && y === 25 - 1) {
          //   this.queue_turn_up();
          // }

          // // down
          // else if (snake.dy === 20) {
          // }

          // // up
          // else if (snake.dy === -20) {
          // }

          if (y === 0) {
            if (this.dy === -20) {
              this.queue_turn_right();
            } else if (this.dx === -20) {
              this.queue_turn_down();
            } else {
              this.queue_turn_down();
            }
          } else if (y === 25 - 1) {
            if (this.dx === -20) {
              this.queue_turn_up();
            } else if (this.dy === 20) {
              this.queue_turn_right();
            } else {
              this.queue_turn_up();
            }
          } else if (this.dx === 20) {
            this.queue_turn_down();
          }
        }
      }

      var snake = new Snake(160, 160, grid);

      class Apple {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      var apple = new Apple(320, 320);

      // get random whole numbers in a specific range
      // @see https://stackoverflow.com/a/1527820/2124254
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
      }

      var count = 0;

      // game loop
      function loop() {
        if (!game_paused) {
          requestAnimationFrame(loop);
        }

        // console.log("dfsfs", localStorage.getItem("lastname"));

        // slow game loop to 15 fps instead of 60 (60/15 = 4)
        if (++count < 4) {
          return;
        }

        count = 0;
        if (snake.autoplay) {
          snake.doOptimalMove(snake.x, snake.y);
        }
        snake.flush_queued_move();

        context.clearRect(0, 0, canvas.width, canvas.height);

        // move snake by it's velocity
        snake.move();

        // wrap snake position horizontally on edge of screen
        if (snake.x < 0) {
          snake.x = canvas.width - grid;
        } else if (snake.x >= canvas.width) {
          snake.x = 0;
        }

        // wrap snake position vertically on edge of screen
        if (snake.y < 0) {
          snake.y = canvas.height - grid;
        } else if (snake.y >= canvas.height) {
          snake.y = 0;
        }

        // keep track of where snake has been. front of the array is always the head
        snake.cells.unshift({ x: snake.x, y: snake.y });

        //   remove cells as we move away from them
        if (snake.cells.length > snake.maxCells) {
          snake.cells.pop();
        }

        // context.fillStyle = "lightgreen";
        // for (let i = 0; i < 25; i++) {
        //   for (let j = 0; j < 25; j++) {
        //     // context.fillRect(i * grid, j * grid, grid - 2, grid - 2);
        //     context.rect(i * grid, j * grid, grid - 1, grid - 1);

        //   }
        // }

        // DEBUG: CELL ID
        // context.fillStyle = "red";
        // for (let i = 0; i < 25; i++) {
        //   for (let j = 0; j < 25; j++) {
        //     // context.fillStyle = "lightgreen";
        //     // context.fillRect(i * grid, j * grid, grid - 2, grid - 2);
        //     // context.rect(i * grid, j * grid, grid - 1, grid - 1);

        //     context.font = `8px arial`;
        //     context.fillText(`${i}:${j}`, i * grid + 2, j * grid + 11.5);
        //   }
        // }
        // context.fill();

        // draw apple
        context.fillStyle = "#ffcb74";
        context.fillRect(apple.x, apple.y, grid - 1, grid - 1);

        // console.log("width", canvas.width);
        context.fillStyle = "#373636";
        // context.fillStyle = "red";
        context.font = `${grid * 0.5}px arial`;
        // context.fillRect(apple.x, apple.y, 3, 3);
        context.fillText("404", apple.x, apple.y + grid / 1.5);

        // draw snake one cell at a time
        context.fillStyle = "#185727";
        snake.cells.forEach(function (cell, index) {
          // drawing 1 px smaller than the grid creates a grid effect in the snake body so you can see how long it is

          //   if (index == 0) {
          //     context.fillStyle = "red";
          //     context.fillRect(cell.x, cell.y, grid - 1, grid - 1);
          //   } else {
          //     context.fillStyle = "#185727";
          //     context.fillRect(cell.x, cell.y, grid - 1, grid - 1);
          //   }
          context.fillStyle = calculateGradient(
            snake.maxCells,
            index,
            SNAKE_BODY_GRADIENT.end,
            SNAKE_BODY_GRADIENT.start
          );
          context.fillRect(cell.x, cell.y, grid - 1, grid - 1);

          // Draw eyes
          if (index === 0) {
            // context.fillStyle = "red";
            // context.fillRect(cell.x, cell.y, grid - 1, grid - 1);

            // Draw the white dots for the eyes
            context.fillStyle = "white";

            // console.log(snake);
            const eyeRadius = 2;

            // left
            if (snake.dx === 20) {
              context.beginPath();
              context.arc(cell.x + 15, cell.y + 6, eyeRadius, 0, 2 * Math.PI);
              context.fill();

              context.beginPath();
              context.arc(cell.x + 15, cell.y + 14, eyeRadius, 0, 2 * Math.PI);
              context.fill();
            }

            //Right
            else if (snake.dx === -20) {
              context.beginPath();
              context.arc(cell.x + 5, cell.y + 6, eyeRadius, 0, 2 * Math.PI);
              context.fill();

              context.beginPath();
              context.arc(cell.x + 5, cell.y + 14, eyeRadius, 0, 2 * Math.PI);
              context.fill();
            }

            // down
            else if (snake.dy === 20) {
              context.beginPath();
              context.arc(cell.x + 6, cell.y + 15, eyeRadius, 0, 2 * Math.PI);
              context.fill();

              context.beginPath();
              context.arc(cell.x + 14, cell.y + 15, eyeRadius, 0, 2 * Math.PI);
              context.fill();
            }

            // up
            else if (snake.dy === -20) {
              context.beginPath();
              context.arc(cell.x + 6, cell.y + 5, eyeRadius, 0, 2 * Math.PI);
              context.fill();

              context.beginPath();
              context.arc(cell.x + 14, cell.y + 5, eyeRadius, 0, 2 * Math.PI);
              context.fill();
            }
          }

          // snake ate apple
          if (cell.x === apple.x && cell.y === apple.y) {
            // snake.maxCells++;
            // SNAKE_EAT_SOUND.play();
            snake.increase_length();

            // canvas is 400x400 which is 25x25 grids
            // apple.x = getRandomInt(0, 25) * grid;
            // apple.y = getRandomInt(0, 25) * grid;
            apple = new Apple(
              getRandomInt(0, 25) * grid,
              getRandomInt(0, 25) * grid
            );

            // console.log("eaating apple", snake.score, "  ", highscore);

            if (
              snake.score > personal_best_score ||
              personal_best_score === null
            ) {
              pb_broken = true;
              personal_best_score = snake.score;
              localStorage.setItem("snake_highscore", personal_best_score);
            }
          }

          // check collision with all cells after this one (modified bubble sort)
          for (var i = index + 1; i < snake.cells.length; i++) {
            // snake occupies same space as a body part. reset game
            // Death
            if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
              //   game_paused = true;

              //   while (game_paused) {
              //     console.log(game_paused);
              //   }
              // snake.x = 160;
              // snake.y = 160;
              // snake.cells = [];
              // snake.maxCells = SNAKE_INITIAL_LENGTH;
              // snake.dx = grid;
              // snake.dy = 0;
              send_score_to_save(username, snake.score, 60);

              snake = new Snake(160, 160, grid);

              apple.x = getRandomInt(0, 25) * grid;
              apple.y = getRandomInt(0, 25) * grid;
            }
          }
        });

        // Draw score
        context.font = "50px serif";
        context.fillStyle = "#ffcb74";
        context.fillText(calculateScore(snake.maxCells), 400, 40);

        // Draw highscore
        context.font = "50px serif";
        context.fillStyle = "#ffcb74";
        context.fillText(
          personal_best_score ? personal_best_score : 0,
          450,
          40
        );
      }

      // listen to keyboard events to move the snake
      document.addEventListener("keydown", function (e) {
        console.log("eeeeeee", e.which);
        if (game_paused) {
          console.log("unpausing");
          unpause_game();
        }
        // p key
        else if (e.which === 80) {
          console.log("pause called", game_paused);
          pause_game();
        }

        // left arrow key
        if ((e.which === 37 || e.which === 65) && snake.dx === 0) {
          snake.queue_turn_left();
        }
        // up arrow key
        else if ((e.which === 38 || e.which === 87) && snake.dy === 0) {
          snake.queue_turn_up();
        }
        // right arrow key
        else if ((e.which === 39 || e.which === 68) && snake.dx === 0) {
          snake.queue_turn_right();
        }
        // down arrow key
        else if ((e.which === 40 || e.which === 83) && snake.dy === 0) {
          snake.queue_turn_down();
        }
        // c key
        else if (e.which === 67) {
          snake.autoplay = !snake.autoplay;

          console.log("Cheating: autoplay toggled");
        }
      });

      // start the game
      requestAnimationFrame(loop);
    </script>

    <style>
      #leaderboard {
        font-family: Arial, sans-serif;
        font-size: 16px;
        width: 200px;
        margin: 0 auto;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }

      #leaderboard th {
        background-color: #f0f0f0;
        padding: 10px;
        border-bottom: 1px solid #ccc;
      }

      #leaderboard td {
        padding: 10px;
        border-bottom: 1px solid #ccc;
      }

      /* #leaderboard tr:hover {
        background-color: #f2f2f2;
      } */

      #leaderboard th,
      #leaderboard td {
        text-align: left;
      }

      #leaderboard th:first-child,
      #leaderboard td:first-child {
        width: 20%;
      }

      #leaderboard th:nth-child(2),
      #leaderboard td:nth-child(2) {
        width: 30%;
      }

      #leaderboard th:nth-child(3),
      #leaderboard td:nth-child(3) {
        width: 20%;
      }

      #leaderboard th:nth-child(4),
      #leaderboard td:nth-child(4) {
        width: 30%;
      }
    </style>
  </body>
</html>
